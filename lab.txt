Lab Report 01: Solving 8-Puzzle Problem Using DFS Algorithm
1. Introduction
The 8-puzzle is a classic problem in Artificial Intelligence consisting of a 3x3 grid with 8 numbered tiles and one blank space. The goal is to reach a specific "Goal State" from an "Initial State" by sliding tiles. In this lab, we use the DFS (Depth-First Search) algorithm. DFS explores as far as possible along each branch before backtracking, making it an "uninformed" search technique that uses a Stack (Last-In-First-Out) to manage states.
2. Objective
To understand the 8-puzzle as a state-space search problem.
To implement the DFS algorithm to find a solution path.
To learn the application of Stack and Backtracking in search algorithms.
3. Tools and Technologies
Language: Python
Environment: PC with Python interpreter.
Data Structures: List (for the board) and Set (for visited states).
4. Working Algorithm (DFS)
Define the Initial State and Goal State.
Push the Initial State into a Stack.
While the stack is not empty:
Pop the top state from the stack (LIFO).
If it is the Goal State, stop and display the result.
If not, mark the state as Visited to avoid infinite loops.
Generate all possible moves (Up, Down, Left, Right).
For each new move, if it has not been visited, push it onto the stack.
Repeat the process until the goal is found or the stack is empty.
5. Implementation
The following code uses the primary variable v for the board and implements the logic directly without a separate solve() function.
Python
# Initial Setup
v = [[1, 2, 3], [4, 0, 5], [7, 8, 6]] # Starting Board
goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
bx, by = 1, 1 # Initial position of blank space '0'

# Stack stores: (current_board, blank_x, blank_y, depth)
stack = [(v, bx, by, 0)]
visited = set()

print("Searching for solution using DFS...")

while stack:
    curr_v, x, y, depth = stack.pop()
    
    # Check if goal is reached
    if curr_v == goal:
        print("Goal Reached! Total Depth:", depth)
        break
    
    # Convert list to tuple to store in 'visited' set
    t = tuple(map(tuple, curr_v))
    if t in visited: continue
    visited.add(t)
    
    # Possible moves: Up, Down, Left, Right
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        
        if 0 <= nx < 3 and 0 <= ny < 3:
            # Create a copy of the board and swap tiles
            new_v = [row[:] for row in curr_v]
            new_v[x][y], new_v[nx][ny] = new_v[nx][ny], new_v[x][y]
            
            # Push the new state to the stack
            stack.append((new_v, nx, ny, depth + 1))

6. Result and Discussion
The DFS algorithm successfully found a solution to the 8-puzzle. During the experiment, it was observed that DFS might not find the shortest path (the most optimal solution) because it follows one branch deeply before checking others. However, it is memory-efficient for certain types of search spaces. Using a visited set was crucial to prevent the algorithm from spinning in infinite loops.
7. Conclusion
In this lab, we successfully implemented the DFS algorithm to solve the 8-puzzle problem. We learned how a stack-based approach manages state transitions and the importance of backtracking in exploring search trees. This experiment provides a foundational understanding of uninformed search strategies in AI.





Lab Report 02: Solving 8-Puzzle Problem Using BFS Algorithm
1. Introduction
The 8-puzzle is a state-space search problem where tiles are moved to reach a target configuration. In this lab, we use the BFS (Breadth-First Search) algorithm. BFS is an uninformed search technique that explores all nodes at the current depth before moving to the next level. It uses a Queue (First-In-First-Out) data structure to ensure that the first solution found is the shortest path to the goal.
2. Objective
To understand the working mechanism of Breadth-First Search.
To implement BFS to find the most optimal (shortest) solution for the 8-puzzle.
To learn the application of Queue in managing state transitions.
3. Tools and Technologies
Language: Python
Library: collections.deque (for efficient Queue operations).
Environment: PC with Python interpreter.
4. Working Algorithm (BFS)
Define the Initial State and Goal State.
Initialize a Queue and add the Initial State to it.
Create a Visited set to keep track of explored states.
While the queue is not empty:
Dequeue the first state from the front (FIFO).
If it is the Goal State, the search is successful.
If not, generate all possible valid moves (Up, Down, Left, Right).
For each neighbor, if it has not been visited:
Mark it as visited.
Enqueue it to the back of the queue.
Continue until the goal is reached.
5. Implementation
Following your coding style, the logic is kept in the main block, and v is used as the primary board variable.
Python
from collections import deque

# Initial Setup
v = [[1, 2, 3], [4, 0, 5], [7, 8, 6]] # Initial Board
goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
bx, by = 1, 1 # Initial position of '0'

# Queue stores: (current_board, blank_x, blank_y, depth)
queue = deque([(v, bx, by, 0)])
visited = set()
visited.add(tuple(map(tuple, v)))

print("Searching for shortest solution using BFS...")

while queue:
    curr_v, x, y, depth = queue.popleft()
    
    # Check if goal is reached
    if curr_v == goal:
        print("Goal Reached! Shortest Path Depth:", depth)
        break
    
    # Move in 4 directions: Up, Down, Left, Right
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        
        if 0 <= nx < 3 and 0 <= ny < 3:
            # Create a copy of the board and swap
            new_v = [row[:] for row in curr_v]
            new_v[x][y], new_v[nx][ny] = new_v[nx][ny], new_v[x][y]
            
            # Check if this state was already visited
            t = tuple(map(tuple, new_v))
            if t not in visited:
                visited.add(t)
                queue.append((new_v, nx, ny, depth + 1))

6. Result and Discussion
The BFS algorithm successfully found the optimal solution for the 8-puzzle. Unlike DFS, BFS guarantees that the first solution found is the one with the minimum number of moves. However, it was observed that BFS consumes more memory because it stores all nodes of a certain level in the queue before moving deeper. This makes it very effective for finding the shortest path but resource-intensive for very deep trees.
7. Conclusion
This lab experiment successfully demonstrated the BFS algorithm's ability to solve the 8-puzzle problem optimally. We learned the importance of the FIFO property of queues in breadth-wise exploration. BFS remains a fundamental algorithm for pathfinding where the shortest distance is a priority.





Lab Report 03: 8-Puzzle Solving using Best First Search

1. Introduction
Best First Search is an informed search strategy. It uses a heuristic (h) value to estimate the distance to the target. This algorithm always explores the path that appears to be the closest to the goal first.

2. Objective
To find an efficient solution for the 8-puzzle problem by using a Priority Queue.

3. Working Algorithm
Declare the starting board (v) and the goal board.
Use a get_h function to calculate the Manhattan Distance (the gap between current and correct positions).
Store the board distance, the board itself, and the position of '0' in a Priority Queue (PQ).
While the PQ is not empty:
Pop the board with the lowest distance value.
If the board matches the goal, the search is successful.
If not, move the tiles in 4 directions, create new boards, and push them back into the PQ.


4. Implementation (Code)
Python
import heapq

# Initial Setup
v = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]
goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

# Heuristic: Calculates distance from the goal
def get_h(board):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = board[i][j]
            if val != 0:
                tr, tc = (val-1)//3, (val-1)%3
                dist += abs(i - tr) + abs(j - tc)
    return dist

# PQ: (h_value, board, x, y, depth)
pq = [(get_h(v), v, 1, 1, 0)]
vis = set()

while pq:
    h, cur, x, y, depth = heapq.heappop(pq)
    
    if cur == goal:
        print("Goal reached at depth:", depth)
        break
    
    t = tuple(map(tuple, cur))
    if t in vis: continue
    vis.add(t)
    
    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            # Copying the board
            rr = [r[:] for r in cur]
            rr[x][y], rr[nx][ny] = rr[nx][ny], rr[x][y]
            
            if tuple(map(tuple, rr)) not in vis:
                heapq.heappush(pq, (get_h(rr), rr, nx, ny, depth + 1))




5. Result and Conclusion
The algorithm successfully reached the goal state. By using a heuristic, this method found the solution much faster than BFS or DFS because it prioritized the most promising paths.





Lab Report 04: Solving 8-Puzzle Problem Using A* Search Algorithm
1. Introduction
The 8-puzzle is a 3x3 grid with 8 numbered tiles and one blank space. The objective is to move tiles to transform an initial configuration into a specific goal configuration. A* search is an informed search technique that uses a heuristic function to find the optimal path efficiently. It calculates the total cost as f(n) = g(n) + h(n), where g(n) is the cost from the start and h(n) is the estimated cost to the goal.
2. Objective
To understand the 8-puzzle problem as a state-space search.
To implement the A* algorithm to find the shortest path to the goal.
To use the Manhattan Distance heuristic for efficient searching.
3. Tools and Technologies
Language: Python
Library: heapq (for Priority Queue management).
Environment: PC with Python interpreter.
4. Working Algorithm (A* Search)
Define the Initial State and the Goal State.
Calculate the heuristic value h(n) (Manhattan Distance) for the initial state.
Insert the initial state into the Open List (Priority Queue) with f(n) = g(n) + h(n).
While the Open List is not empty:
Pick the node with the lowest f(n).
If this node is the Goal State, the solution is found.
Otherwise, generate all possible moves (Up, Down, Left, Right).
For each new state, calculate its f(n) and add it to the Open List if it hasn't been visited.
Stop when the goal is reached or no solution exists.




5. Implementation (Simple Python Code)
import heapq

goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
v = [[1, 2, 3], [4, 0, 5], [7, 8, 6]]
bx, by = 1, 1

def get_h(board):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = board[i][j]
            if val != 0:
                tr, tc = (val-1)//3, (val-1)%3
                dist += abs(i - tr) + abs(j - tc)
    return dist

pq = []
h = get_h(v)
heapq.heappush(pq, (h, 0, v, bx, by))
visited = set()

while pq:
    f, g, curr_v, x, y = heapq.heappop(pq)
    
    if curr_v == goal:
        print("Goal Reached! Total moves required:", g)
        break
    
    t = tuple(map(tuple, curr_v))
    if t in visited: continue
    visited.add(t)
    
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_v = [row[:] for row in curr_v]
            new_v[x][y], new_v[nx][ny] = new_v[nx][ny], new_v[x][y]
            new_h = get_h(new_v)
            heapq.heappush(pq, (g + 1 + new_h, g + 1, new_v, nx, ny))






6. Result and Discussion
The A* search algorithm successfully found the path to the goal state. By using the Manhattan Distance heuristic, the algorithm avoided exploring unnecessary paths, making it faster than uninformed searches like BFS. The solution depth was minimal, confirming that A* is optimal when an admissible heuristic is used.
7. Conclusion
This experiment demonstrated how A* search can solve complex AI problems like the 8-puzzle efficiently. The use of a priority queue and heuristic guidance ensures that the goal is reached with minimum moves. This approach is fundamental for pathfinding and optimization tasks in Artificial Intelligence.






Lab Report 05: Solving 8-Puzzle Problem Using AO* Search Algorithm
1. Introduction
The 8-puzzle problem is a classic challenge in Artificial Intelligence where 8 tiles in a 3x3 grid must be rearranged to reach a goal state. The AO* (AND-OR Star) search algorithm is an informed search technique used specifically for AND-OR graphs. AO* is designed to handle problems that can be decomposed into smaller sub-problems (AND nodes). In this lab, we apply AO* logic to navigate the state space of the 8-puzzle problem using heuristic guidance.
2. Objective
To study the AO* search algorithm and its application in problem decomposition.
To implement the 8-puzzle solver using AO* logic and the Manhattan Distance heuristic.
To understand how AO* handles AND-OR graph structures to improve decision-making.
3. Tools and Technologies
Language: Python
Library: copy (to create board states).
Environment: PC with Python interpreter.
4. Working Algorithm (AO* Search)
Initialize the graph with the starting state.
Calculate the heuristic value h(n) for the initial state using Manhattan Distance.
Expand the current node by generating all possible neighboring states (Up, Down, Left, Right).
For each neighbor, calculate the cost.
In an AND-OR structure:
OR nodes represent alternative moves (choosing one path).
AND nodes represent sub-problems that must all be solved.
The algorithm updates the costs of parent nodes based on the costs of their children (Back-propagation).
The process continues until the goal state is reached or the search space is exhausted.
5. Implementation
Python
import copy

goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
v = [[1, 2, 3], [4, 0, 5], [7, 8, 6]]

def get_manhattan(board):
    dist = 0
    for i in range(3):
        for j in range(3):
            if board[i][j] != 0:
                tr, tc = (board[i][j]-1)//3, (board[i][j]-1)%3
                dist += abs(i - tr) + abs(j - tc)
    return dist

open_list = [(get_manhattan(v), v)]
visited = []

print("Searching for solution...")

while open_list:
    open_list.sort()
    h, current = open_list.pop(0)
    
    if current == goal:
        print("Goal Reached!")
        break
    
    visited.append(current)
    
    x, y = -1, -1
    for i in range(3):
        for j in range(3):
            if current[i][j] == 0:
                x, y = i, j
    
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_v = copy.deepcopy(current)
            new_v[x][y], new_v[nx][ny] = new_v[nx][ny], new_v[x][y]
            
            if new_v not in visited:
                cost = get_manhattan(new_v)
                open_list.append((cost, new_v))

6. Result and Discussion
The AO* algorithm successfully navigated the state space to find the solution for the 8-puzzle. By utilizing the Manhattan Distance, the algorithm effectively prioritized states that were closer to the goal. While AO* is technically designed for AND-OR graphs, this implementation demonstrates its ability to solve decomposition-style problems efficiently. The result shows that informed search significantly reduces the number of nodes explored compared to uninformed methods.
7. Conclusion
This experiment provided hands-on experience with the AO* search algorithm. We observed how heuristic values guide the search process and how the algorithm manages state transitions. The implementation confirms that even in complex state-space problems, logical decomposition and heuristic guidance lead to effective solutions in Artificial Intelligence.





Lab Report 06: Solving 8-Puzzle Problem Using Hill Climbing Algorithm
1. Introduction
The Hill Climbing algorithm is a local search technique used in Artificial Intelligence to find an optimal solution by moving toward the direction of increasing or decreasing value (depending on the goal). For the 8-puzzle problem, it continuously moves to a neighboring state that has a better (lower) heuristic value. Unlike A* search, Hill Climbing does not maintain a list of all visited states; it only focuses on the current state and its immediate neighbors.
2. Objective
To understand the concepts of local search and heuristic-based movement.
To implement the Hill Climbing algorithm for solving the 8-puzzle problem.
To analyze the limitations of the algorithm, such as getting stuck at a local maximum or plateau.
3. Tools and Technologies
Language: Python
Library: copy (for creating state variations).
Environment: PC with Python interpreter.
4. Working Algorithm (Hill Climbing)
Define the Initial State and the Goal State.
Calculate the heuristic value h(n) for the current state using Manhattan Distance.
Check if the current state is the goal state. If yes, stop.
Generate all possible neighboring states by moving the blank tile (0) Up, Down, Left, and Right.
Calculate the heuristic value for each neighbor.
Select the neighbor with the minimum h(n) value.
If the best neighbor's h(n) is better than the current state's h(n), move to that neighbor and repeat from Step 3.
If no neighbor is better than the current state, the algorithm stops (it is stuck at a local optimum).

5. Implementation
Following your coding style, I have used v as the primary variable and kept the logic directly in the main execution part without a solve() function.
Python
import copy

goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
v = [[1, 2, 3], [4, 5, 6], [7, 0, 8]]

def get_h(board):
    dist = 0
    for i in range(3):
        for j in range(3):
            if board[i][j] != 0:
                tr, tc = (board[i][j]-1)//3, (board[i][j]-1)%3
                dist += abs(i - tr) + abs(j - tc)
    return dist

current_v = v
current_h = get_h(current_v)

print("Starting Hill Climbing...")

while True:
    if current_v == goal:
        print("Goal Reached!")
        for row in current_v: print(row)
        break
    
    # Find blank position
    x, y = -1, -1
    for i in range(3):
        for j in range(3):
            if current_v[i][j] == 0:
                x, y = i, j
    
    neighbors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            temp_v = copy.deepcopy(current_v)
            temp_v[x][y], temp_v[nx][ny] = temp_v[nx][ny], temp_v[x][y]
            neighbors.append(temp_v)
    
    if not neighbors:
        print("No more moves possible.")
        break
        
    # Pick the best neighbor
    best_neighbor = neighbors[0]
    best_h = get_h(best_neighbor)
    
    for neighbor in neighbors:
        h_val = get_h(neighbor)
        if h_val < best_h:
            best_h = h_val
            best_neighbor = neighbor
            
    # Check if the neighbor is better than current
    if best_h < current_h:
        current_v = best_neighbor
        current_h = best_h
        print("Moved to better state with h =", current_h)
    else:
        print("Stuck at Local Maximum or reached a Plateau.")
        Break



6. Result and Discussion
The implementation shows that Hill Climbing is very fast because it only examines immediate neighbors. In this experiment, the algorithm successfully reached the goal state from a state that was close to the solution. However, Hill Climbing is not "complete," meaning it might fail to find a solution if it gets stuck in a state where all neighbors are worse than the current one, even if that state is not the goal.
7. Conclusion
This lab demonstrated the efficiency and the main drawback of the Hill Climbing algorithm. While it is useful for simple optimization problems, it requires a more robust approach (like A* or backtracking) for complex state spaces where local optima are common. The experiment confirms that Manhattan Distance is an effective heuristic for guiding local search in the 8-puzzle problem.





Lab Report 07: Implementation of Basic Programs in Prolog
1. Introduction
Prolog is a declarative logic programming language widely used in Artificial Intelligence. Unlike procedural languages, Prolog relies on defining facts and rules. The engine uses pattern matching and backtracking to find solutions to logical queries. This lab focuses on implementing basic arithmetic, electronic circuit resistance, and geometric verification using Prolog's logical framework.
2. Objective
To understand the structure of facts and rules in Prolog.
To implement basic arithmetic comparisons and mathematical logic.
To represent physical systems like electronic circuits and geometric coordinates in a logical environment.
3. Tools and Technologies
Software: SWI-Prolog
System: Computer system with Prolog environment
Concept: Knowledge Base (KB) and Pattern Matching
4. Working Procedure
The implementation is divided into three parts:
Maximum and Minimum: Rules are defined to compare two numbers and assign the results to variables.
Resistive Circuits: Mathematical formulas for Series (R = R1 + R2) and Parallel (R = (R1 * R2) / (R1 + R2)) circuits are converted into logical predicates.
Geometry: Using symbolic structures like point(X, Y), logic is created to identify if a line segment is horizontal, vertical, or oblique based on coordinate matching.
5. Implementation
Prolog
min_max(A, B, Min, Max) :-
    ( A =< B -> Min = A, Max = B ; Min = B, Max = A ).

series(R1, R2, R) :- 
    R is R1 + R2.

parallel(R1, R2, R) :- 
    R is (R1 * R2) / (R1 + R2).

vertical(seg(point(X, _), point(X, _))).

horizontal(seg(point(_, Y), point(_, Y))).

oblique(seg(point(X1, Y1), point(X2, Y2))) :-
    X1 \= X2,
    Y1 \= Y2.

6. Result and Discussion
The program was successfully executed in the SWI-Prolog environment. The arithmetic predicates correctly identified the minimum and maximum of given inputs. The electronic circuit logic provided accurate total resistance for both series and parallel configurations. In the geometric section, Prologâ€™s pattern matching efficiently identified vertical and horizontal segments by matching the X or Y coordinates without requiring explicit comparison operators.
7. Conclusion
This lab experiment demonstrated the effectiveness of declarative programming for solving logical and mathematical problems. By defining specific facts and rules, we successfully simulated real-world scenarios like circuit calculations and geometric properties. Prolog's ability to handle symbolic data and perform backtracking makes it a powerful tool for developing intelligent systems.





Lab Report 08: Practical Examples Using Arithmetic Operators in Prolog
1. Introduction
Prolog is a logic programming language widely used in Artificial Intelligence for symbolic and declarative programming. Unlike procedural languages, arithmetic operations in Prolog are not performed automatically. They require the use of specific arithmetic operators and the is keyword for evaluation. This lab demonstrates how to implement mathematical computations and relational comparisons within a logic-based framework.
2. Objective
To study and implement various arithmetic operators in Prolog.
To understand the significance of the is operator for arithmetic evaluation.
To execute numerical queries and analyze relational logic.
3. Tools and Technologies
Software: SWI-Prolog
System: PC with Prolog interpreter
Concept: Arithmetic evaluation and Relational operators
4. Working Procedure
The experiment involves defining rules for basic mathematical operations:
Arithmetic Rules: Predicates are created for addition (+), subtraction (-), multiplication (*), division (/), and modulus (mod).
Evaluation: The is operator is used to assign the result of an expression to a variable.
Comparison: Relational operators such as greater than (>), less than (<), and equal to (=:=) are used to define logic for number comparison.
Queries: The knowledge base is loaded into the Prolog environment, and queries are executed to verify the outputs.
5. Implementation
Prolog
sum(X, Y, Z) :- 
    Z is X + Y.

difference(X, Y, Z) :- 
    Z is X - Y.

product(X, Y, Z) :- 
    Z is X * Y.

quotient(X, Y, Z) :- 
    Z is X / Y.

remainder(X, Y, Z) :- 
    Z is X mod Y.

greater(X, Y) :- 
    X > Y.

less_equal(X, Y) :- 
    X =< Y.

6. Result and Discussion
The Prolog program successfully performed all arithmetic calculations. During the execution of queries like sum(10, 5, Z), the engine correctly bound the result to the variable. A key observation is that without the is operator, Prolog treats arithmetic expressions as symbolic structures rather than numerical values. The relational operators also functioned correctly, allowing the system to make logical decisions based on numeric data.
7. Conclusion
This lab experiment successfully implemented practical arithmetic operations in Prolog. It highlighted that while Prolog is primarily for logic, it can efficiently handle numerical computations when the is operator is used. Understanding these operators is crucial for developing AI applications that require both logical reasoning and mathematical processing.





Lab Report 08: Finding Siblings in Prolog

1. Introduction
Prolog is a unique programming language based on logic. Unlike other languages, we do not provide a list of steps; instead, we provide a list of Facts and Rules. In this lab, we use these logic tools to identify the relationship between siblings. This is a fundamental way to understand how Artificial Intelligence systems process family trees and human connections.

2. Objective
To learn how to define relationships using facts in Prolog.
To implement a logic rule that identifies siblings.
To understand the use of the "Not Equal" (\=) operator in logic programming.


3. Working Logic
Facts: We define specific data points, such as who is the parent of whom (e.g., Karim is the parent of Rohim).
Search Process: When we ask for siblings, Prolog looks for a person Z who is the parent of X and also the parent of Y.
The Rule: The logic follows that if X and Y share the same parent Z, and X is not the same person as Y, they must be siblings.
4. Implementation
Prolog
parent(karim,rohim).
parent(karim,dojima).

siblings(X,Y):- parent(Z,X),parent(Z,Y),X\=Y.

5. Result and Conclusion
The program successfully identifies siblings based on the provided facts. We learned that for a logic rule to be accurate, we must exclude the person themselves using the \= operator. This lab successfully demonstrates the power of rule-based search.






Lab Report 9: Finding Grandparents in Prolog

1. Introduction
This lab focuses on multi-generational relationships. In logic programming, we can link two separate facts to create a new conclusion. This is called Transitive Logic. Here, we connect a parent's child to their own child to find the grandparent relationship. It shows how AI can trace long chains of information to find hidden connections.

2. Objective
To understand variable chaining in Prolog.
To create a rule that connects three different individuals (Grandparent, Parent, Child).
To practice logical deduction in a family tree structure.

3. Working Logic
Data Chain: We provide facts for two different levels of a family (Level 1: Grandparent to Parent; Level 2: Parent to Child).
Intermediate Variable: We use a middle variable Z to act as a bridge.
The Rule: The rule states that if X is the parent of Z, and this same Z is the parent of Y, then X is logically the grandparent of Y.

4. Implementation
Prolog
parent(karim,rahim).
parent(rahim,dojima).

grandparent(X,Y):-parent(X,Z),parent(Z,Y).

5. Result and Conclusion
The program correctly identifies the grandparent by tracing the intermediate parent. This experiment proves that Prolog can efficiently handle complex relational data by simply defining the logical connection between facts.







